import efl_selection_types;

/*enum Efl.Cnp.Type
{
   primary, [[Primary text selection (highlighted or selected text)]]
   secondary, [[Used when primary selection is in use]]
   dnd, [[Drag and Drop]]
   clipboard [[Clipboard selectio (ctrl+C)]]
}

//should be more general: Efl.Data.Format???
enum Efl.Cnp.Format
{
   [[Selection format]]
   targets = -1, [[For matching every possible atom]]
   none = 0x0, [[Content is from outside of Elementary]]
   text = 0x01, [[Plain unformatted text: Used for things that don't want rich markup]]
   markup = 0x2, [[Edje textblock markup, including inline images]]
   image = 0x4, [[Images]]
   vcard = 0x08, [[Vcards]]
   html = 0x10 [[Raw HTML-like data (eg. webkit)]]
}

struct Efl.Cnp.Selection
{
   [[EFL Cnp selection]]
   data: void_ptr; [[data]]
   length: int; [[length]]
}*/


//mixin or class
//class: how to get top_win and set selection
//mixin: every object can get/set selection, how to handle it efficiently
//class Efl.Cnp (Efl.Object) {
interface Efl.Selection {
   [[Efl Copy and Paste class]]
   //legacy_prefix: elm_cnp;
   //eo_prefix: efl_selection;
   methods {
      selection_set {
         params {
            @in type: Efl.Cnp.Type; [[Selection Type]]
            @in format: Efl.Cnp.Format; [[Selection Format]]
            @in buf: const(void_ptr);
            @in len: int; [[The buffer's length.]]
            @in seat: Efl.Input.Device @optional;[[Specified seat for multiple seats case.]]
         }
      }
      selection_get {
         params {
            @in type: Efl.Cnp.Type; [[Selection Type]]
            @in format: Efl.Cnp.Format; [[Selection Format]]
            @in seat: Efl.Input.Device @optional;[[Specified seat for multiple seats case.]]
         }
        return: future<generic_value>; [[Future of selection that is ready]]
      }
      selection_clear {
         params {
            @in type: Efl.Cnp.Type; [[Selection Type]]
            @in seat: Efl.Input.Device @optional; [[Specified seat for multiple seats case.]]
         }
      }
      selection_loss_feedback { //name!!!
         params {
            @in type: Efl.Cnp.Type; [[Selection type]]
         }
         return: future<generic_value>; [[Future of selection that is ready]]
      }
   }
   implements {
   }
   events {
      selection,loss; [[Called when selection is lost]]
   }
}
